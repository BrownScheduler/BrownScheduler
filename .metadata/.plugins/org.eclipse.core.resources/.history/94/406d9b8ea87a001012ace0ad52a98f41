package roundrobin2;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;


public class ConstraintHandler {

	private Turn _t;
	private int _roundNum;
	private Round _r;
	public ConstraintHandler(Turn tournament, int roundNum) {
		_t = tournament;
		_roundNum = roundNum;
	}

	public Round createRound() {
		int fieldNum = 0;
		_r = new Round(_t, "Round " + Integer.toString(_roundNum), _roundNum);
		Random rand = new Random();
		int offset = 0;
		HashSet<Team> paired = new HashSet<Team>();
		LinkedList<Team> unpaired = new LinkedList<Team>(_t.getTeams().getMembers());
		Collections.shuffle(unpaired);
		int i = 1;
		while(!unpaired.isEmpty()){
			_r.addGame(getNextGame(unpaired, i++, _t.getFields().getMembers().get(fieldNum)));
			fieldNum = (fieldNum + 1) % _t.getFields().getMembers().size(); 
		}
		return _r;
	}
	
	public Game getNextGame(LinkedList<Team> unpaired, int number, Field field){
		Team t1 = unpaired.pop();
		Team t2 = null;
		Game g = new Game(_t, this._r, "Round " + Integer.toString(_roundNum) + " Game " + number);
		for(Team t : unpaired){
			if(!t1.hasfacedBefore(t, _roundNum)){
				t2 = t;
				t1.addFacedTeam(t2, _roundNum);
				break;
			}
		}
		g.setHome(t1);
		g.setAway(t2);
		g.setField(field);
		RefereeGrouping possibleRefs = g.getPossibleRefs(field);
		List<Referee> shuffled = possibleRefs.getMembers();
		Collections.shuffle(shuffled);
		if(!shuffled.isEmpty())
			g.setHeadReferee(shuffled.remove(0));
		if(!shuffled.isEmpty())
			g.setAssistantReferee(shuffled.remove(0));
		return g;
	}

}
